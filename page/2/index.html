<!doctype html>



  


<html class="theme-next muse use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.0.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.1" />






<meta name="description" content="分享自己的学习经历，实用技巧">
<meta property="og:type" content="website">
<meta property="og:title" content="MockingBird">
<meta property="og:url" content="http://blog.mcbird.cn/page/2/index.html">
<meta property="og:site_name" content="MockingBird">
<meta property="og:description" content="分享自己的学习经历，实用技巧">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="MockingBird">
<meta name="twitter:description" content="分享自己的学习经历，实用技巧">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Muse',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 0,
      author: '博主'
    }
  };
</script>




  <link rel="canonical" href="http://blog.mcbird.cn/page/2/"/>

  <title> MockingBird </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  



  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "//hm.baidu.com/hm.js?f86a845dc60f2f2581b1e0dd02613510";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>








  
  
    
  

  <div class="container one-collumn sidebar-position-left 
  
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">MockingBird</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle">记录 Web 前端成长旅程</p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2015/10/23/react-style-guide/" itemprop="url">
                  React 编程风格指南
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2015-10-23T23:02:27+08:00" content="2015-10-23">
              2015-10-23
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/javascript/" itemprop="url" rel="index">
                    <span itemprop="name">javascript</span>
                  </a>
                </span>

                
                
                  ， 
                

              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/javascript/react/" itemprop="url" rel="index">
                    <span itemprop="name">react</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2015/10/23/react-style-guide/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2015/10/23/react-style-guide/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>本文讨论的是 <code>React.js</code> 编程中的一些编程风格，团队开发中遵循统一的风格有利于提高代码的阅读体验。<br>本文译自<a href="https://github.com/Khan/style-guides/blob/master/style/react.md" target="_blank" rel="external">React style guide</a>。下面将从三个方面来讲。</p>
<h2 id="语法">语法</h2><h3 id="方法顺序遵循生命周期放在前面，_render()_方法放在最后">方法顺序遵循生命周期放在前面， <code>render()</code> 方法放在最后</h3><p>在 <code>react</code> 组件内部，方法的顺序如下：</p>
<ol>
<li>生命周期方法（按照时间先后顺序依次为： <code>getDefaultProps</code>, <code>getInitialState</code>, <code>componentWillMount</code>, <code>componentDidMount</code>, <code>componentWillReceiveProps</code>, <code>shouldComponentUpdate</code>, <code>componentWillUpdate</code>, <code>componentDidUpdate</code>, <code>componentWillUnmount</code> ）</li>
<li>其他的方法</li>
<li><code>render</code> 方法</li>
</ol>
<h3 id="事件处理函数的命名">事件处理函数的命名</h3><p>采用 “handle” + “EventName” 的方式来命名<br>Example：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Component onClick=&#123;this.handleClick&#125; onLaunchMissiles=&#123;this.handleLaunchMissiles&#125; /&gt;</span><br></pre></td></tr></table></figure></p>
<h3 id="事件函数作为属性时的命名">事件函数作为属性时的命名</h3><p>为了跟 <code>react</code> 的事件命名保持一致： <code>onClick</code>, <code>onDrag</code>, <code>onChange</code>, 等等，采用如下格式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Component onLaunchMissiles=&#123;this.handleLaunchMissiles&#125; /&gt;</span><br></pre></td></tr></table></figure></p>
<h3 id="元素跟_return_放在同一行">元素跟 <code>return</code> 放在同一行</h3><p>为了节约空间，采用下面的写法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">return &lt;div&gt;</span><br><span class="line">	...</span><br><span class="line">&lt;/div&gt;;</span><br></pre></td></tr></table></figure></p>
<p>而不是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">return (      // &quot;div&quot; 与 &quot;return&quot; 不在同一行</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        ...</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">);</span><br></pre></td></tr></table></figure></p>
<h3 id="对HTML的属性进行对齐和排序">对HTML的属性进行对齐和排序</h3><p>如果属性不是太多，那就放在同一行，否则就把每一个属性都单独写一行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;div className=&quot;highlight&quot; key=&quot;highlight-div&quot;&gt;</span><br><span class="line">&lt;div</span><br><span class="line">    className=&quot;highlight&quot;</span><br><span class="line">    key=&quot;highlight-div&quot;</span><br><span class="line">&gt;</span><br><span class="line">&lt;Image</span><br><span class="line">    className=&quot;highlight&quot;</span><br><span class="line">    key=&quot;highlight-div&quot;</span><br><span class="line">/&gt;</span><br></pre></td></tr></table></figure></p>
<p>而不是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;div className=&quot;highlight&quot;      // 属性没有在单独行</span><br><span class="line">     key=&quot;highlight-div&quot;</span><br><span class="line">&gt;</span><br><span class="line">&lt;div                            // 闭合便签不在单独的行</span><br><span class="line">    className=&quot;highlight&quot;</span><br><span class="line">    key=&quot;highlight-div&quot;&gt;</span><br><span class="line">&lt;div                            // 属性没有排序（一般重要的属性写在前面）</span><br><span class="line">    key=&quot;highlight-div&quot;</span><br><span class="line">    className=&quot;highlight&quot;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></p>
<h3 id="一个文件只导出一个_react_类">一个文件只导出一个 react 类</h3><p>每一个 <code>.jsx</code> 应该只能导出单独的 <code>react 类</code>。这样有利于测试，因为这些测试框架要求一个文件导出的就是一个函数。<br><em>注意：你依然可以在一个文件中定义多个类，只要保证导出的只有一个即可。</em></p>
<h2 id="语言特色">语言特色</h2><h3 id="确保“呈现型”的组件功能单一">确保“呈现型”的组件功能单一</h3><p>把 <code>react 组件</code> 分为“逻辑型组件”和“呈现型组件” 是很有必要的。前者包含的是业务逻辑，里面不应该包含HTML；后者一般是可复用的，可以包含HTML。前者可以拥有自己的内部的 <code>state</code>，而后者不应该拥有。</p>
<h3 id="多用_props">多用 props</h3><p>如果能用 <code>props</code> 就不要用 <code>state</code>，这一定程度上可以减少应用程序的复杂度。<br>一般的模式是：创建一个“无状态”的组件（呈现型组件），只负责呈现数据，把包含 <code>state</code> 的“逻辑型组件”做为这些组件的父级组件。 然后把它内部的 <code>state</code> 作为 <code>props</code>传递给下面的呈现型组件。这些逻辑型组件包含了所有的交互逻辑。</p>
<h3 id="使用_propTypes">使用 propTypes</h3><p><code>react 组件</code> 都应该完成 <code>propTypes</code> 验证。每一个 <code>this.props</code> 的属性都应该有一个与之对应的 <code>propTypes</code>。<br>避免使用这些没有描述意义的 prop-types:</p>
<ul>
<li>React.PropTypes.any</li>
<li>React.PropTypes.array</li>
<li>React.PropTypes.object</li>
</ul>
<p>最好使用：</p>
<ul>
<li>React.PropTypes.arrayOf</li>
<li>React.PropTypes.objectOf</li>
<li>React.PropTypes.instanceOf</li>
<li>React.PropTypes.shape</li>
</ul>
<h3 id="永远不要在DOM中保存_state">永远不要在DOM中保存 state</h3><p>不要通过 <code>data-</code> 属性或class类。所有的信息应该都存储在javascript中，或者在React组件中，或者在React store 中，如果使用了类似 <code>Redux</code> 这样的框架的话。</p>
<h2 id="React_库和组件">React 库和组件</h2><h3 id="不要使用_backbone_模型">不要使用 backbone 模型</h3><p>直接使用 flux action，或者 <code>$.ajax</code> 来代替。</p>
<h3 id="尽量少用_jQuery_就少用">尽量少用 jQuery 就少用</h3><p>永远也不要用jquery去操作DOM。<br>尝试避免jquery插件的使用。有必要的话，把jquery插件包装在React组件中。<br>你可以使用 <code>$.ajax</code>（但是不要用其他方法，像 <code>$.post</code>） 来进行网络通信。</p>
<h3 id="复用组件">复用组件</h3><p>你可以从<a href="http://react-components.com/" target="_blank" rel="external">react-components.com</a>获取第三方React组件。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2015/09/18/javascript-timers/" itemprop="url">
                  javascript 定时器工作原理
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2015-09-18T11:01:58+08:00" content="2015-09-18">
              2015-09-18
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/javascript/" itemprop="url" rel="index">
                    <span itemprop="name">javascript</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2015/09/18/javascript-timers/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2015/09/18/javascript-timers/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>说到 javascript 中的定时器，我们肯定会想到 <code>setTimeout()</code> 和 <code>setInterval()</code> 这两个函数。本文将从 <em>事件循环（Event Loop）</em> 的角度来分析两者的工作原理和区别。</p>
<h2 id="setTimeout()">setTimeout()</h2><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Window/setTimeout" target="_blank" rel="external">MDN</a>对 <code>setTimeout</code> 的定义为：</p>
<blockquote>
<p>在指定的延迟时间之后调用一个函数或执行一个代码片段。</p>
</blockquote>
<h3 id="语法">语法</h3><p><code>setTimeout</code> 的语法非常简单，第一个参数为回调函数，第二个参数为延时的时间。函数返回一个数值类型的ID唯一标示符，此ID可以用作 <code>clearTimeout</code> 的参数来取消定时器：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> timeoutID = <span class="built_in">window</span>.setTimeout(code, delay);</span><br></pre></td></tr></table></figure></p>
<p>IE0+ 还支持回调参数的传入：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> timeoutID = <span class="built_in">window</span>.setTimeout(func, delay, [param1, param2, ...]);</span><br></pre></td></tr></table></figure></p>
<h2 id="setInterval()">setInterval()</h2><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Window/setInterval" target="_blank" rel="external">MDN</a> 对 setInterval 的定义为：</p>
<blockquote>
<p>周期性地调用一个函数(function)或者执行一段代码。</p>
</blockquote>
<p>由于 <code>setInterval</code> 和 <code>setTimeout</code> 的用法一样，所以这里不再列出。</p>
<h2 id="对第二个参数（delay）的说明">对第二个参数（delay）的说明</h2><p>由于javascript 的事件循环机制，导致<strong>第二个参数并不代表延迟delay毫秒之后立即执行回调函数，而是尝试将回调函数加入到事件队列</strong>。实际上，<code>setTimeout</code> 和 <code>setInterval</code> 在这一点上处理又存在区别：</p>
<ul>
<li>setTimeout：延时delay毫秒之后，啥也不管，直接将回调函数加入事件队列。</li>
<li>setInterval: 延时delay毫秒之后，先看看事件队列中是否存在还没有执行的回调函数（setInterval的回调函数），如果存在，就不要再往事件队列里加入回调函数了。</li>
</ul>
<p>所以，当我们的代码中存在耗时的任务时，定时器并不会表现的如我们所想的那样。</p>
<h2 id="通过一个例子来理解">通过一个例子来理解</h2><p>下面的代码，本来希望能够在 <code>100ms</code> 和 <code>200ms</code> 的时候（也就是刚好等待 <code>100ms</code>）调用回调函数：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> timerStart1 = now();</span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'第一个setTimeout回调执行等待时间：'</span>, now() - timerStart1);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> timerStart2 = now();</span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'第二个setTimeout回调执行等待时间：'</span>, now() - timerStart2);</span><br><span class="line">  &#125;, <span class="number">100</span>);</span><br><span class="line">&#125;, <span class="number">100</span>);</span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// 第一个setTimeout回调执行等待时间： 106</span></span><br><span class="line"><span class="comment">// 第二个setTimeout回调执行等待时间： 107</span></span><br></pre></td></tr></table></figure></p>
<p>这样的结果看上去正是我们所想的那样，但是一旦我们在代码中加入了耗时的任务时候，结果就不像我们所期望的那样了：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> timerStart1 = now();</span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'第一个setTimeout回调执行等待时间：'</span>, now() - timerStart1);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> timerStart2 = now();</span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'第二个setTimeout回调执行等待时间：'</span>, now() - timerStart2);</span><br><span class="line">  &#125;, <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">  heavyTask();  <span class="comment">// 耗时任务</span></span><br><span class="line">&#125;, <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> loopStart = now();</span><br><span class="line">heavyTask(); <span class="comment">// 耗时任务</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'heavyTask耗费时间：'</span>, now() - loopStart);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">heavyTask</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> s = now();</span><br><span class="line">  <span class="keyword">while</span>(now() - s &lt; <span class="number">1000</span>) &#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">now</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// heavyTask耗费时间： 1015</span></span><br><span class="line"><span class="comment">// 第一个setTimeout回调执行等待时间： 1018</span></span><br><span class="line"><span class="comment">// 第二个setTimeout回调执行等待时间： 1000</span></span><br></pre></td></tr></table></figure></p>
<p>两个 <code>setTimeout</code> 的等待事件由于耗时任务的存在不再是 <code>100ms</code> 了！我们来描述一下事情的经过：</p>
<ol>
<li>首先，第一个耗时任务（<code>heavyTask()</code>）开始执行，它需要大约 <code>1000ms</code> 才能执行完毕。</li>
<li>从耗时任务开始执行，过了 <code>100ms</code>， 第一个 <code>setTimeout</code> 的回调函数期望执行，于是被加入到事件队列，但是此时前面的耗时任务还没执行完，所以它只能在队列中等待，直到耗时任务执行完毕它才开始执行，所以结果中我们开的看到的是： <code>第一个setTimeout回调执行等待时间： 1018</code>。</li>
<li>第一个 <code>setTimeout</code> 回调一执行，又开启了第二个 <code>setTimeout</code>， 这个定时器也是期望延时 <code>100ms</code> 之后能够执行它的回调函数。 但是，在第一个 <code>setTimeout</code> 又存在一个耗时任务，所有它的剧情跟第一个定时器一样，也等待了 1000ms 才开始执行。</li>
</ol>
<p>可以用下面的图来概括：<br><img src="http://7xiyp1.com1.z0.glb.clouddn.com/d83d0ac5f1c6e766b2bd61422df501d5.png" alt="setTimeout"></p>
<p>再来看 <code>setInterval</code> 的一个例子：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> intervalStart = now();</span><br><span class="line">setInterval(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'interval距定义定时器的时间：'</span>, now() - loopStart);</span><br><span class="line">&#125;, <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> loopStart = now();</span><br><span class="line">heavyTask();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'heavyTask耗费时间：'</span>, now() - loopStart);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">heavyTask</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> s = now();</span><br><span class="line">  <span class="keyword">while</span>(now() - s &lt; <span class="number">1000</span>) &#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">now</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// heavyTask耗费时间： 1013</span></span><br><span class="line"><span class="comment">// interval距定义定时器的时间： 1016</span></span><br><span class="line"><span class="comment">// interval距定义定时器的时间： 1123</span></span><br><span class="line"><span class="comment">// interval距定义定时器的时间： 1224</span></span><br></pre></td></tr></table></figure></p>
<p>上面这段代码，我们期望每隔 <code>100ms</code> 就打出一条日志。相对于 <code>setTimeout</code> 的区别， <code>setInterval</code> 在<strong>准备把回调函数加入到事件队列的时候，会判断队列中是否还有未执行的回调</strong>，如果有的话，它就不会再往队列中添加回调函数。 不然，会出现多个回调同时执行的情况。</p>
<p>可以用下面的图来概括：<br><img src="http://7xiyp1.com1.z0.glb.clouddn.com/7738497179ec4dfb252dd6c3e46ac8da.png" alt="setInterval"></p>
<h2 id="总结">总结</h2><p>上面对javascript定时器执行原理进行了简要的分析，希望能够帮助我们更深入的理解javascript。文中有描述不当的地方可以在评论中指出。</p>
<blockquote>
<p>文章地址：<a href="http://blog.mcbird.cn/2015/09/18/javascript-timers/">http://blog.mcbird.cn/2015/09/18/javascript-timers/</a></p>
</blockquote>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2015/09/11/react-on-es6-plus/" itemprop="url">
                  [译]在 React.js 中使用 ES6+
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2015-09-11T15:54:36+08:00" content="2015-09-11">
              2015-09-11
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/javascript/" itemprop="url" rel="index">
                    <span itemprop="name">javascript</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2015/09/11/react-on-es6-plus/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2015/09/11/react-on-es6-plus/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>原文地址： <a href="http://babeljs.io/blog/2015/06/07/react-on-es6-plus/" target="_blank" rel="external">http://babeljs.io/blog/2015/06/07/react-on-es6-plus/</a></p>
</blockquote>
<p><img src="http://7xiyp1.com1.z0.glb.clouddn.com/652b57761014ee46dc3114e22229b92f.png" alt="babel.js"></p>
<p>在今年对 Instagram Web 进行全新的设计的时候，我喜欢在写 React 组件的时候，用上一些 ES6+ 的新特性。请允许我列举这些能够改变你写 React 应用方式的新特性。比起以往，这些特性能够使你撸起码来更加容易、有趣！</p>
<h2 id="类（Class）">类（Class）</h2><p>使用 ES6+ 来编写 React 组件最明显的变化就是我们定义组件（类）的语法的方式。我们可以用定义一个继承了 <code>React.Component</code> 的ES6 类来代替原本使用 <code>React.createClass</code> 的来创建类的方式：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Photo</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">img</span> <span class="attr">alt</span>=<span class="string">&#123;this.props.caption&#125;</span> <span class="attr">src</span>=<span class="string">&#123;this.props.src&#125;</span> /&gt;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span></span><br></pre></td></tr></table></figure></p>
<p>我们可以发现这种写法使得定义组件的方式变得更加简洁：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// The ES5 way</span></span><br><span class="line"><span class="keyword">var</span> Photo = React.createClass(&#123;</span><br><span class="line">  handleDoubleTap: <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123; … &#125;,</span><br><span class="line">  render: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; … &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// The ES6+ way</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Photo</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  handleDoubleTap(e) &#123; … &#125;</span><br><span class="line">  render() &#123; … &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这样我们可以少写一对圆括号、一个分号、每个方法的冒号和 <code>function</code> 关键字。</p>
<p>所有生命周期方法都可以采用这种方式来定义。 但是 <code>componentWillMount</code> 还可以用 <code>constructor</code> 来代替：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// The ES5 way</span></span><br><span class="line"><span class="keyword">var</span> EmbedModal = React.createClass(&#123;</span><br><span class="line">  componentWillMount: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; … &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// The ES6+ way</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EmbedModal</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="comment">// Operations usually carried out in componentWillMount go here</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="属性初始化（property_initializers）">属性初始化（property initializers）</h2><p>在 ES6+ 类中，属性类型 <code>prop type</code> 和默认属性 <code>default prop</code> 可以通过类中的 <code>static</code> 来声明。同时，组件的初始状态（ <code>initial state</code> ）可以通过 ES7 的<a href="https://gist.github.com/jeffmo/054df782c05639da2adb" target="_blank" rel="external">属性初始化（property initializers）</a>来完成：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// The ES5 way</span></span><br><span class="line"><span class="keyword">var</span> Video = React.createClass(&#123;</span><br><span class="line">  getDefaultProps: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      autoPlay: <span class="literal">false</span>,</span><br><span class="line">      maxLoops: <span class="number">10</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  getInitialState: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      loopsRemaining: <span class="keyword">this</span>.props.maxLoops,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  propTypes: &#123;</span><br><span class="line">    autoPlay: React.PropTypes.bool.isRequired,</span><br><span class="line">    maxLoops: React.PropTypes.number.isRequired,</span><br><span class="line">    posterFrameSrc: React.PropTypes.string.isRequired,</span><br><span class="line">    videoSrc: React.PropTypes.string.isRequired,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// The ES6+ way</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Video</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> defaultProps = &#123;</span><br><span class="line">    autoPlay: <span class="literal">false</span>,</span><br><span class="line">    maxLoops: <span class="number">10</span>,</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">static</span> propTypes = &#123;</span><br><span class="line">    autoPlay: React.PropTypes.bool.isRequired,</span><br><span class="line">    maxLoops: React.PropTypes.number.isRequired,</span><br><span class="line">    posterFrameSrc: React.PropTypes.string.isRequired,</span><br><span class="line">    videoSrc: React.PropTypes.string.isRequired,</span><br><span class="line">  &#125;</span><br><span class="line">  state = &#123;</span><br><span class="line">    loopsRemaining: <span class="keyword">this</span>.props.maxLoops,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>ES7 中在构造函数（ <code>constructor</code> ）下的属性初始化操作中的 <code>this</code> 指向的是类的实例，所以初始状态（ <code>initial state</code> ）可以通过 <code>this.prop</code> （即传入的参数）来设定。</p>
<h2 id="箭头函数（Arrow_function）">箭头函数（Arrow function）</h2><p><code>React.createClass</code> 方法在你的组件上做了一些额外的绑定工作，以确保在组件实实例的方法内部， <code>this</code> 指向的是组件实例自身。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Autobinding, brought to you by React.createClass</span></span><br><span class="line"><span class="keyword">var</span> PostInfo = React.createClass(&#123;</span><br><span class="line">  handleOptionsButtonClick: <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// Here, 'this' refers to the component instance.</span></span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;showOptionsModal: <span class="literal">true</span>&#125;);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>由于我们使用 ES6+ 的语法定义类的时候没有采用 <code>React.createClass</code> 的方式，所以，这样看来我们不得不手动来绑定这些方法中 <code>this</code> 的指向：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Manually bind, wherever you need to</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PostInfo</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="comment">// Manually bind this method to the component instance...</span></span><br><span class="line">    <span class="keyword">this</span>.handleOptionsButtonClick = <span class="keyword">this</span>.handleOptionsButtonClick.bind(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  handleOptionsButtonClick(e) &#123;</span><br><span class="line">    <span class="comment">// ...to ensure that 'this' refers to the component instance here.</span></span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;showOptionsModal: <span class="literal">true</span>&#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>幸运的是，通过 ES6+ 的箭头函数（ Arrow functions ）和属性初始化（ property initializers ）这两个特性使得把函数的 <code>this</code> 指向绑定为组件的实例变得非常的简单：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PostInfo</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  handleOptionsButtonClick = (e) =&gt; &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;showOptionsModal: <span class="literal">true</span>&#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>函数体内的 <code>this</code> 对象，绑定定义时所在的对象，而不是使用时所在的对象。而恰好属性初始化（ property initializers ）刚好在这个作用域内。</p>
<h2 id="动态属性名_&amp;_字符串模板">动态属性名 &amp; 字符串模板</h2><p>在 ES6+ 中对 <em>对象字面量的扩展</em> 使得我们可以在对象字面量中使用表达式来对属性命名。如果是在 ES5 中，我们也许只能这样做：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Form = React.createClass(&#123;</span><br><span class="line">  onChange: <span class="function"><span class="keyword">function</span>(<span class="params">inputName, e</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> stateToSet = &#123;&#125;;</span><br><span class="line">    stateToSet[inputName + <span class="string">'Value'</span>] = e.target.value;</span><br><span class="line">    <span class="keyword">this</span>.setState(stateToSet);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>但是，在 ES6+ 中，我们不仅可以在对象字面量属性的定义中使用表达式，还有使用使用 <em>字符串模板</em> ：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Form</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  onChange(inputName, e) &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">      [<span class="string">`<span class="subst">$&#123;inputName&#125;</span>Value`</span>]: e.target.value,</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="析构_&amp;_扩展运算符">析构 &amp; 扩展运算符</h2><p>我们在编写组件的过程中，经常遇到要从父组件要把自己的很多属性多传给子组件的情况。有了 ES6+ 的 <em>析构</em> 和 <em>扩展运算符</em> 特性，这变得非常的方便：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AutoloadingPostsGrid</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">var</span> &#123;</span><br><span class="line">      className,</span><br><span class="line">      ...others,  <span class="comment">// contains all properties of this.props except for className</span></span><br><span class="line">    &#125; = <span class="keyword">this</span>.props;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&#123;className&#125;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">PostsGrid</span> &#123;<span class="attr">...others</span>&#125; /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;this.handleLoadMoreClick&#125;</span>&gt;</span>Load more<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span></span><br></pre></td></tr></table></figure></p>
<p>我们可以把 <em>扩展运算符</em> 属性和普通的属性结合起来使用，这样使得我们可以利用优先级来使用属性的默认值和属性的覆盖。下面这个元素会获得一个 <code>override</code> 的类（ <code>class</code> ），及时 <code>this.props</code> 中有传递 <code>className</code> 属性。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div &#123;...this.props&#125; className=<span class="string">"override"</span>&gt;</span><br><span class="line">  …</span><br><span class="line">&lt;<span class="regexp">/div&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>下面这种写法，可以给元素设定默认的 <code>className</code>：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div className=<span class="string">"base"</span> &#123;...this.props&#125;&gt;</span><br><span class="line">  …</span><br><span class="line">&lt;<span class="regexp">/div&gt;</span></span><br></pre></td></tr></table></figure></p>
<h2 id="最后">最后</h2><p>我希望你能够享受 ES6+ 的这些特性给你在编写 React.js 中带来的好处。感谢我的同事他们为这篇文章作出的贡献，还有，特别的感谢 Babel 团队，使得我们可以随意的使用这些特性。</p>
<blockquote>
<p>文章地址：<a href="http://blog.mcbird.cn/2015/09/11/react-on-es6-plus/">http://blog.mcbird.cn/2015/09/11/react-on-es6-plus/</a></p>
</blockquote>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2015/08/28/learning-gulp/" itemprop="url">
                  gulp 入门
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2015-08-28T18:14:02+08:00" content="2015-08-28">
              2015-08-28
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/tools/" itemprop="url" rel="index">
                    <span itemprop="name">tools</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2015/08/28/learning-gulp/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2015/08/28/learning-gulp/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><img src="http://7xiyp1.com1.z0.glb.clouddn.com/8d3777b647413ea22733efca334a294a.png" alt="gulp logo"></p>
<h2 id="Gulp_是什么？">Gulp 是什么？</h2><p><a href="http://gulpjs.com/" title="gulp" target="_blank" rel="external">Gulp</a> 是 <a href="http://gruntjs.com/" target="_blank" rel="external">Grunt</a> 的替代者。作为构建工具，Gulp 更具有语法简洁易懂的优势，所以学习成本更低。<br>利用 Gulp， 我们不仅可以对HTML、CSS（LESS|SASS）、JS（CoffeeScript）进行编译；还可以监听文件的变化，同时借助 <em>livereloader</em> 实时地刷新页面；甚至还可以对图片进行压缩优化。下面记录一下我的 <em>Gulp 学习之旅</em> 。</p>
<h2 id="安装_Gulp">安装 Gulp</h2><p>Gulp 需要 <a href="node.js">nodejs.org</a> 运行环境，首先请确保你的机器上安装了 <code>node.js</code>。</p>
<ol>
<li><p>安装全局 Gulp</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i --global gulp</span><br></pre></td></tr></table></figure>
</li>
<li><p>安装本地（作为开发依赖项）Gulp</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i --save-dev gulp</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建 <em>gulpfile.js</em> 文件</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> gulp = <span class="built_in">require</span>(<span class="string">'gulp'</span>);</span><br><span class="line"></span><br><span class="line">gulp.task(<span class="string">'default'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 将你的默认的任务代码放在这</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'hello world!'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
<li><p>运行 Gulp<br>在终端运行：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gulp</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p><code>gulp</code> 后不接参数，那么默认会执行 <code>default</code> 任务，所以上面的代码会在终端中输出 <code>hello world!</code>。</p>
<h2 id="使用插件压缩脚本">使用插件压缩脚本</h2><p><em>gulp</em> 依靠各种<a href="http://gulpjs.com/plugins/" target="_blank" rel="external">插件（plugin）</a>实现常用功能。比方说我们要对所有的 <em>*.js</em> 文件进行压缩（借助 <a href="https://npmjs.org/package/gulp-uglify/" target="_blank" rel="external">gulp-uglify 插件</a>）<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> gulp = <span class="built_in">require</span>(<span class="string">'gulp'</span>),</span><br><span class="line">    uglify = <span class="built_in">require</span>(<span class="string">'gulp-uglify'</span>);</span><br><span class="line"></span><br><span class="line">gulp.task(<span class="string">'default'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  gulp.src(<span class="string">'js/*.js'</span>)</span><br><span class="line">      .pipe(uglify())</span><br><span class="line">      .pipe(gulp.dest(<span class="string">'build/js'</span>))；</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>重新在终端运行 <code>gulp</code>， Gulp 会对 <code>js/</code> 目录下的所有 <code>js</code>文件进行压缩，然后输出到 <code>build/js</code> 目录。</p>
<h2 id="给任务（Task）命名">给任务（Task）命名</h2><p>上面我们定义了一个对 <code>js</code> 进行压缩的任务，并把它放在了默认的（<code>default</code>）任务下，其实我们最好把处理脚本的相关操作抽出来，当独作为一个任务（例如 <code>scripts</code> ）更为合理：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">gulp.task(<span class="string">'scripts'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    gulp.src(<span class="string">'js/*.js'</span>)</span><br><span class="line">        .pipe(uglify())</span><br><span class="line">        .pipe(gulp.dest(<span class="string">'build/js'</span>));</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>我们可以在终端运行指定的任务项，只需在 <code>gulp</code> 后面接上任务名参数：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gulp scripts</span><br></pre></td></tr></table></figure></p>
<h2 id="监听文件的改变">监听文件的改变</h2><p>我们可以借助 <a href="https://npmjs.org/package/gulp-watch/" target="_blank" rel="external">gulp-watch 插件</a> 来监听文件的改变：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> gulp = <span class="built_in">require</span>(<span class="string">'gulp'</span>),</span><br><span class="line">    uglify = <span class="built_in">require</span>(<span class="string">'gulp-uglify'</span>),</span><br><span class="line">    watch = <span class="built_in">require</span>(<span class="string">'gulp-watch'</span>);</span><br><span class="line"></span><br><span class="line">gulp.task(<span class="string">'watch'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    gulp.watch(<span class="string">'js/*.js'</span>, [<span class="string">'scripts'</span>]);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>这里我们定义了一个 <code>watch</code> 任务，监听 <code>js/*.js</code> 文件的改变， <code>watch()</code> 的第二个参数是文件发生改变之后的回调，这里表示，文件一旦发生改变，就会执行前面我们定义的 <code>scripts</code> 任务，重新对 <code>js</code> 文件进行压缩处理。</p>
<h2 id="用Gulp来编译LESS">用Gulp来编译LESS</h2><p>Gulp 不仅可以对 <code>js</code> 进行压缩处理，还可以编译 less/scss 文件，这一功能也是我们经常在项目中用到的。这里需要借助 <a href="https://npmjs.org/package/gulp-less/" target="_blank" rel="external">gulp-less</a> 插件：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> gulp = <span class="built_in">require</span>(<span class="string">'gulp'</span>),</span><br><span class="line">    uglify = <span class="built_in">require</span>(<span class="string">'gulp-uglify'</span>),</span><br><span class="line">    watch = <span class="built_in">require</span>(<span class="string">'gulp-watch'</span>),</span><br><span class="line">    less = <span class="built_in">require</span>(<span class="string">'gulp-less'</span>);</span><br><span class="line"></span><br><span class="line">gulp.task(<span class="string">'styles'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    gulp.src(<span class="string">'less/**/*.less'</span>)</span><br><span class="line">        .pipe(less())</span><br><span class="line">        .pipe(gulp.dest(<span class="string">'css/'</span>));</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<h2 id="使用Plumber来让Gulp保持运行">使用Plumber来让Gulp保持运行</h2><p>如果我们在编写代码的过程中，不小心代码写错了，存在语法错误，那么编译不会被通过，gulp 会在终端抛出异常，同时终止。这不是我们想要的，我们希望存在语法错误是，Gulp 能够给我们提示，并继续保持运行，而不是中断，这个时候就要借助 <a href="https://npmjs.org/package/gulp-plumber/" target="_blank" rel="external">gulp-plumber</a> 来帮我们做这个事：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">gulp.task(<span class="string">'styles'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    gulp.src(<span class="string">'less/**/*.less'</span>)</span><br><span class="line">        .pipe(plumber())</span><br><span class="line">        .pipe(less())</span><br><span class="line">        .pipe(gulp.dest(<span class="string">'css/'</span>))</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p><em>注意：</em> 我们要保证 <code>plumber()</code> 要放在其他操作前面，这样才能捕捉到错误异常。</p>
<h2 id="实时更新（LiveReload）页面">实时更新（LiveReload）页面</h2><p>我们期望代码更新后不仅能够重新编译代码，而且希望浏览器帮我们自己刷新网页，这个时候，我们就需要用到 <a href="https://www.npmjs.com/package/gulp-livereload/" target="_blank" rel="external">gulp-livereload</a> 的帮助了，同时我们需要安装 <a href="https://chrome.google.com/webstore/detail/livereload/jnihajbhpnppcggbcgedagnkighmdlei" target="_blank" rel="external">livereload 的Chrome插件</a>。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">gulp.task(<span class="string">'styles'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    gulp.src(<span class="string">'less/**/*.less'</span>)</span><br><span class="line">        .pipe(plumber())</span><br><span class="line">        .pipe(less())</span><br><span class="line">        .pipe(gulp.dest(<span class="string">'css/'</span>))</span><br><span class="line">        .pipe(livereload());</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p><em>注意：</em> 与 <code>plumber()</code> 相反，我们要把 <code>livereload()</code> 放在操作的最后。</p>
<h2 id="简单的进行图像压缩">简单的进行图像压缩</h2><p>我们可以借助 <a href="https://npmjs.org/package/gulp-imagemin/" target="_blank" rel="external">gulp-imagemin</a> 对图片进行优化：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">gulp.task(<span class="string">'images'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> gulp.src(<span class="string">'src/images/*'</span>)</span><br><span class="line">        .pipe(imagemin())</span><br><span class="line">        .pipe(gulp.dest(<span class="string">'dist/images'</span>));</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<h2 id="自动补全浏览器前缀">自动补全浏览器前缀</h2><p>我们还可以用 <a href="https://npmjs.org/package/gulp-autoprefixer/" target="_blank" rel="external">gulp-autoprefixer</a> 对 CSS3 中的一些属性进行前缀的自动补全（例如 <code>transition, transform 等</code> ）：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">gulp.task(<span class="string">'styles'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    gulp.src(<span class="string">'less/**/*.less'</span>)</span><br><span class="line">        .pipe(plumber())</span><br><span class="line">        .pipe(less())</span><br><span class="line">        .pipe(prefixer(<span class="string">'last 2 versions'</span>))</span><br><span class="line">        .pipe(gulp.dest(<span class="string">'css/'</span>))</span><br><span class="line">        .pipe(livereload());</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p><code>prefixer()</code> 的参数可参考 <a href="https://github.com/ai/browserslist" target="_blank" rel="external">这里</a></p>
<h2 id="最终的_gulpfile-js_配置文件">最终的 gulpfile.js 配置文件</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> gulp = <span class="built_in">require</span>(<span class="string">'gulp'</span>),</span><br><span class="line">    uglify = <span class="built_in">require</span>(<span class="string">'gulp-uglify'</span>),</span><br><span class="line">    watch = <span class="built_in">require</span>(<span class="string">'gulp-watch'</span>),</span><br><span class="line">    less = <span class="built_in">require</span>(<span class="string">'gulp-less'</span>),</span><br><span class="line">    plumber = <span class="built_in">require</span>(<span class="string">'gulp-plumber'</span>),</span><br><span class="line">    livereload = <span class="built_in">require</span>(<span class="string">'gulp-livereload'</span>),</span><br><span class="line">    prefixer = <span class="built_in">require</span>(<span class="string">'gulp-autoprefixer'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Scripts Task</span></span><br><span class="line">gulp.task(<span class="string">'scripts'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    gulp.src(<span class="string">'js/*.js'</span>)</span><br><span class="line">        .pipe(plumber())</span><br><span class="line">        .pipe(uglify())</span><br><span class="line">        .pipe(gulp.dest(<span class="string">'build/js'</span>))</span><br><span class="line">        .pipe(livereload());</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Styles Task</span></span><br><span class="line">gulp.task(<span class="string">'styles'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    gulp.src(<span class="string">'less/**/*.less'</span>)</span><br><span class="line">        .pipe(plumber())</span><br><span class="line">        .pipe(less())</span><br><span class="line">        .pipe(prefixer(<span class="string">'last 2 versions'</span>))</span><br><span class="line">        .pipe(gulp.dest(<span class="string">'css/'</span>))</span><br><span class="line">        .pipe(livereload());</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// HTML Task</span></span><br><span class="line">gulp.task(<span class="string">'html'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    gulp.src(<span class="string">'*.html'</span>)</span><br><span class="line">        .pipe(livereload());</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Image Task</span></span><br><span class="line">gulp.task(<span class="string">'images'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> gulp.src(<span class="string">'src/images/*'</span>)</span><br><span class="line">        .pipe(imagemin())</span><br><span class="line">        .pipe(gulp.dest(<span class="string">'dist/images'</span>));</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Watch Task</span></span><br><span class="line">gulp.task(<span class="string">'watch'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    livereload.listen();</span><br><span class="line">    gulp.watch(<span class="string">'js/*.js'</span>, [<span class="string">'scripts'</span>]);</span><br><span class="line">    gulp.watch(<span class="string">'less/**/*.less'</span>, [<span class="string">'styles'</span>]);</span><br><span class="line">    gulp.watch(<span class="string">'*.html'</span>, [<span class="string">'html'</span>]);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">gulp.task(<span class="string">'default'</span>, [<span class="string">'scripts'</span>, <span class="string">'styles'</span>, <span class="string">'watch'</span>]);</span><br></pre></td></tr></table></figure>
<h2 id="总结">总结</h2><p>上面列出了一些日常开发中比较常用的几种功能，其他更多的功能可<a href="http://gulpjs.com/plugins/" target="_blank" rel="external">参考官方 plugin 库</a>，根据个人需求对其功能继续扩展。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2015/08/15/How-to-Become-a-Great-Front-End-Engineer/" itemprop="url">
                  [译]如何成为一个优秀的前端工程师
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2015-08-15T11:17:30+08:00" content="2015-08-15">
              2015-08-15
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/think/" itemprop="url" rel="index">
                    <span itemprop="name">think</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2015/08/15/How-to-Become-a-Great-Front-End-Engineer/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2015/08/15/How-to-Become-a-Great-Front-End-Engineer/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>原文地址：<a href="http://philipwalton.com/articles/how-to-become-a-great-front-end-engineer/" target="_blank" rel="external">http://philipwalton.com/articles/how-to-become-a-great-front-end-engineer/</a><br>来自Google的前端工程师-<a href="http://philipwalton.com/" target="_blank" rel="external">Philip Walton</a> 分享了自己关于如何成为优秀的工程师的一些观点。个人感觉很有价值，所以翻译成中文，方便大家阅读。 人水平有限，如翻译不妥之处请在评论中指出。</p>
</blockquote>
<p>最近，我收到了读者的邮件，引发了我的一些思考。这是他在邮件中问我的问题：</p>
<blockquote>
<p>Hi Philip, is it okay to ask how you become a great front-end engineer?<br>Any advice?</p>
</blockquote>
<p>我不得不承认，我感到非常的惊讶，居然会被问到这样的问题，因为我从来没有想过自己是一个<code>优秀</code>的前端工程师。实际上，我在这个行业工作的前几年里，我真的不觉得我能够胜任我的工作。我接受了这些工作只是因为我以前没有意识到我知道得东西太少了，我能够得到这些工作只是因为以前面试我的人不知道问我什么问题。</p>
<p>话虽这么说，我最后还是把我自己的角色做得非常好，而且成为了团队里有价值的一员。当我最后离职的时候（下一个职位我还是无法胜任）我通常也会应试那些将要应聘我的职位的人。现在回想那些我面试过的应聘者，让我明白，看待知识的重要性。尽管我一开始在这个领域很薄弱。我现在的自己可能也不会雇佣以前的那个自己，尽管我知道随着工作经验的积累，成功也是可能的。</p>
<p>在Web领域，我工作的越久，越让我意识到<strong>不错的人和真正优秀的人的区别在于不是他们知道什么，而是他们如何思考。</strong> 很明显，知识是很重要的—特别是在某些情况下—但是，在一个快速变化的领域并非如此。你获取知识的方式比你知道那些知识更为重要。而且也许最重要的是：你如何利用你的知识去解决日常生活中的问题。</p>
<p>你可以找到大量谈论知识点、框架和工具的文章，这是知识都是获得一份工作所需要知道的。我想说一些不一样的。在这篇文章中，我会说一说前端工程师应有的心态，希望能够回答最开始的问题：怎样才能做到优秀？</p>
<h2 id="不要只是解决问题，找到问题的根源所在">不要只是解决问题，找到问题的根源所在</h2><p>很多的人只是不断地写一些 CSS 和 Javascript 补丁直到他们发现这些东西可以正常的工作了，然后他们就不管了。我在代码审查的过程中看到了很多这样的做法。</p>
<p>我会经常问别人：“为什么你要在这里加一个 <code>float: left</code> ？” 或者 “这个 <code>overflow:hidden</code> 真的需要吗？”，然后他们会回答：“我不知道，但是如果我删掉他们，就出问题了”。</p>
<p>Javascript 也一样。我看到一些人用 <code>setTimeout</code> 来防止执行顺序上的问题，或者是一些人滥用 <code>stopPropagation()</code> 而没有考虑到它也许会影响页面中的其他事件处理函数。</p>
<p>我遇到过很多相同或类似的问题，如果你从来不花时间去了解问题的根源所在，你会发现你会一遍一遍的遭遇同样的困境。</p>
<p>花时间去深入的研究你的解决方案<em>为什么</em>可行看起来需要耗费很多的精力，但是我发誓它会在将来给你节约很多时间。对你现在工作的系统有一个全面的理解可以减少你将来的猜测和检查工作。</p>
<h2 id="学会预测浏览器领域将来的变化">学会预测浏览器领域将来的变化</h2><p>前端跟后端主要的不同是：后端的运行环境在你的控制之下。但是对于前端而言，相比于后端，它完全不在你的控制范围。你的用户所使用的平台或者设备随时都有可能改变，你的代码需要能够优雅地处理这种情况。</p>
<p>我记得早在2011年的时候，我在一个非常著名的 javascript 框架看到下面这样一段源码（大致如此）：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> isIE6 = !isIE7 &amp;&amp; !isIE8 &amp;&amp; !isIE9;</span><br></pre></td></tr></table></figure>
<p>我知道在现实生活中，<code>feature detaction</code> 并不能100%的有效，有些时候我们不得不采用这种不好的方式或者浏览器白名单的方式，但是任何时候你这样做的时候，你应该预测未来可能会发生什么，即使发生，你的代码也不应该出现bug。</p>
<p>对于我们大多数人而言，我们在现在的工作岗位上写的代码会比我们的任期更长。我8年前写的一些代码现在还会经常用到，这想起来既让人满足又让让感到可怕。</p>
<h2 id="阅读官方文档">阅读官方文档</h2><p>浏览器 bug 总是存在的，但是，当两个浏览器执行相同的代码表现却不一致时，人们经常假设，而不是亲自去检查，只是把他们认为的表现好的叫做“正常”浏览器，表现异常的叫“不正常”浏览器。但并非总是这样，当你做出了错误的假设时，任何你选择的解决方法在未来也许会失效。</p>
<p>一个现实的例子就是 <code>flex items</code> 的默认最小尺寸。根据<a href="http://www.w3.org/TR/css-flexbox/#min-size-auto" target="_blank" rel="external">官方文档</a>，<code>flex items</code> 的 <code>min-width</code> 和 <code>min-height</code> 是 <code>auto</code> (而不是 0)，这意味着，它们的尺寸不会比它们的内容还要小。 但是在过去的8个月里，只有 <code>Firefox</code> 是唯一一个正确的实现这一标准的浏览器。</p>
<p>如果你遇到过这类跨浏览器的兼容性问题，而且你注意到你的页面在 Chrome，IE，Opera，和 Safari 上表现一致，唯独 Firefox 上表现不同时，你肯定会猜测这是 Firefox 自己的问题。</p>
<p>当两个或多个浏览器在渲染相同的代码表现不一致时， 你应该花一些时间去研究到底哪个浏览器才是正确的，然后用正确的方式写下你的代码。你的作品才会是面向未来的。</p>
<p>另外，优秀的前端工程师经常都是站在变化的最前列的，他们会在这些技术成为主流之前就采用这些技术，甚至为这些技术作出贡献。如果你凭借你自己的实力去查找官方文档，而且能够想象一个技术在你能够在浏览器中用它的之前将会是如何工作的，你将成为能够谈论这个官方标准会对开发造成什么影响的人。</p>
<h2 id="阅读其他人的代码">阅读其他人的代码</h2><p>阅读其他人的代码，无疑是成为一个更好的开发者的最好方式。</p>
<p>自己解决问题是学习的最好方式，但是如果这些问题都是你以前解决过的，你很快就会进入平稳期（很难有上升的空间）。阅读其他人的代码可以为你打开处理问题的新的思路。而且阅读和理解别人写的代码的能力也是在跟团队合作或者参与开源项目时至关重要的能力。</p>
<p>实际上，我认为在面试一个应聘者是只让他们写代码—新的代码，是最大的错误。我应聘的时候，从来没有被叫过去阅读一些已经存在的代码，在这些代码中找出问题，然后解决它。这是非常不好的，因为作为一个工程师，很多时候我们是在别人的代码上添加和改变一些代码。很少从头写一些新的。</p>
<h2 id="跟比你聪明的人一起工作">跟比你聪明的人一起工作</h2><p>在我印象你，比起后端开发者，更多的前端开发者希望成为一个自由职业者（全栈）。也许是前端工程师更趋向于自学，而后端工程师更趋向于学术。</p>
<p>自学并为你自己工作的问题是无法从比你聪明的人身上得到好处。没有人来跟你讨论观点或者帮你审查代码。</p>
<p>我强烈的建议，至少在你职业生涯初期，在一个团队中工作，特别是跟一群比你更聪明更有经验的人工作。</p>
<p>如果你已经结束你的职业生涯，现在只是为你自己工作，那么参与到开源中来。 贡献开源项目会给你很多与团队合作的机会。</p>
<h2 id="重复造轮子">重复造轮子</h2><p>在商业上，重复造轮子是不好的，但是对于学习来说并非如此。你也许尝试从 <code>npm</code> 上获取预输入控件或者事件委托库，但是想象一下如果你自己尝试创造这些东西的话会学到更多。</p>
<p>我确定一些正在阅读这篇文章的人对此感到强烈反对。不要误会我的意思。我不是说你永远也不应该使用第三方库。使用优秀的库是非常明智的事情。</p>
<p>但是，在这篇文章中，我要说的是如何从一个不错的工程师成为一个优秀的工程师。大部分我认为的这个领域中优秀的工程师都是这些优秀的第三方库的维护者。</p>
<p>你也许从来没有构建够自己的 javascript 库，但是你依然能够在你的职业生涯中获得成功，但是，可能你从来没有理解到解决问题的核心。</p>
<p>在这个行业中，人们经常问起的一个问题是：我接下来应该做什么？ 如果你问了这个问题，为什么不去尝试重新创造一个你喜欢的 javascript 库或者 CSS 框架，而不是尝试一些新的工具或者写一个新的 app。 这样做的好处是，及时你遇到了困难，你也可以从目前已有的库中的源码找到答案。</p>
<h2 id="把你学到的东西写下来">把你学到的东西写下来</h2><p>最后， 你应该把你学到的东西写下来。有太多的理由这样做了，但是，也许最重要的原因是这样可以强迫你更好地理解你所学的东西。如果你无法解释其原理，这是一个很好的机会说明你并没有完全搞懂它。很多时候你没有意识到你不懂，直到你爸它写下来。</p>
<p>在我的经验中，书写、做一个演讲、以及写一些 demos 是强迫我自己完全弄懂一个东西的最好方式，从里到外。及时没有一个人会看你写的东西，但是做这件事的过程更有价值。</p>
<blockquote>
<p>文章地址：<a href="http://blog.mcbird.cn/2015/08/15/How-to-Become-a-Great-Front-End-Engineer/">http://blog.mcbird.cn/2015/08/15/How-to-Become-a-Great-Front-End-Engineer/</a></p>
</blockquote>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel  sidebar-panel-active ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="http://7xip55.com1.z0.glb.clouddn.com/pp1.jpeg"
               alt="McBird" />
          <p class="site-author-name" itemprop="name">McBird</p>
          <p class="site-description motion-element" itemprop="description">分享自己的学习经历，实用技巧</p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">23</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          
            <div class="site-state-item site-state-categories">
              <a href="/categories">
                <span class="site-state-item-count">11</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">19</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/CodingMonkeyzh" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://weibo.com/1914017207" target="_blank" title="微博">
                  
                    <i class="fa fa-fw fa-weibo"></i>
                  
                  微博
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://www.zhihu.com/people/zhou-quan-31-68" target="_blank" title="知乎">
                  
                    <i class="fa fa-fw fa-globe"></i>
                  
                  知乎
                </a>
              </span>
            
          
        </div>

        
        

        
        

      </section>

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy;  2015 - 
  <span itemprop="copyrightYear">2016</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">McBird</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="http://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Muse
  </a>
</div>

        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.1"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.1"></script>



  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"codingmonkeyzh"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  
    
  






  
  
  

  

  

</body>
</html>
